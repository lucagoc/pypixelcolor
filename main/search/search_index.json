{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"pypixelcolor","text":"<p>pypixelcolor (also known as <code>iPixel-CLI</code>) is a Python library and CLI tool for controlling iPixel Color LED matrix devices via Bluetooth Low Energy (BLE). It allows you to send commands to the device to manipulate the LED display, retrieve device information, and more.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>\ud83d\udcdd Send text: Display custom messages with various fonts and animations.</li> <li>\ud83d\uddbc\ufe0f Send images: Display images and GIFs on the matrix.</li> <li>\u2699\ufe0f Control settings: Adjust brightness, orientation, and power.</li> <li>\ud83d\udd52 Modes: Switch between Clock, Rhythm, and Fun modes.</li> <li>\ud83d\udc0d Scriptable: Full Python library support for automation.</li> <li>\ud83d\udda5\ufe0f CLI: Easy to use command-line interface.</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>You can install <code>pypixelcolor</code> via pip:</p> <pre><code>pip install pypixelcolor\n</code></pre>"},{"location":"#quick-start","title":"Quick Start","text":""},{"location":"#command-line-interface-cli","title":"Command Line Interface (CLI)","text":"<p>Scan for devices:</p> <pre><code>pypixelcolor --scan\n</code></pre> <p>Send text to a device:</p> <pre><code>pypixelcolor -a &lt;MAC_ADDRESS&gt; -c send_text \"Hello World\"\n</code></pre> <p>Learn more about the CLI</p>"},{"location":"#python-library","title":"Python Library","text":"<pre><code>import pypixelcolor\n\nclient = pypixelcolor.Client(\"XX:XX:XX:XX:XX:XX\")\nclient.connect()\nclient.send_text(\"Hello World\")\nclient.disconnect()\n</code></pre> <p>Learn more about the Library</p>"},{"location":"commands/","title":"Commands","text":""},{"location":"commands/#clear","title":"<code>clear</code>","text":"<p>Clears the EEPROM.</p> Source code in <code>src/pypixelcolor/commands/clear.py</code> <pre><code>def clear():\n    \"\"\"\n    Clears the EEPROM.\n    \"\"\"\n    cmd = bytes([\n        4,     # Command length\n        0,     # Reserved\n        3,     # Command ID\n        0x80,  # Command type ID\n    ])\n    return single_window_plan(\"clear\", cmd)\n</code></pre>"},{"location":"commands/#delete","title":"<code>delete</code>","text":"<p>Delete a specific slot by its index.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Index of the slot to delete.</p> required Source code in <code>src/pypixelcolor/commands/delete.py</code> <pre><code>def delete(n: int):\n    \"\"\"\n    Delete a specific slot by its index.\n\n    Args:\n        n: Index of the slot to delete.\n    \"\"\"\n    if not (0 &lt;= int(n) &lt;= 255):\n        raise ValueError(\"Slot index must be between 0 and 255\")\n    cmd = bytes([\n        7,      # Command length\n        0,      # Reserved\n        2,      # Command ID\n        1,      # Command type ID\n        1,      # Reserved\n        0,      # Reserved\n        int(n)  # Slot index\n    ])\n    return single_window_plan(\"delete_slot\", cmd)\n</code></pre>"},{"location":"commands/#send_image","title":"<code>send_image</code>","text":"<p>Send an image or animation. Supports <code>.png</code>, <code>.webp</code>, <code>.jpg</code>, <code>.jpeg</code>, <code>.bmp</code>, <code>.tiff</code>, <code>.gif</code> and <code>.heic, .heif</code> if pillow-heif library is installed.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>File path.</p> required <code>device_info</code> <code>Optional[DeviceInfo]</code> <p>Device information (injected automatically by DeviceSession).</p> <code>None</code> <code>resize_method</code> <code>Union[str, ResizeMethod]</code> <p>Resize method - 'crop' (default) or 'fit'.        'crop' will fill the entire target area and crop excess.       'fit' will fit the entire image with black padding.</p> <code>CROP</code> <code>save_slot</code> <code>int</code> <p>If &gt;= 1, will save to that slot.</p> <code>0</code> Note <p>If device_info is available, the image will be automatically resized to match the target device dimensions if necessary.</p> Source code in <code>src/pypixelcolor/commands/send_image.py</code> <pre><code>def send_image(path: Union[str, Path], resize_method: Union[str, ResizeMethod] = ResizeMethod.CROP, device_info: Optional[DeviceInfo] = None, save_slot: int = 0):\n    \"\"\"\n    Send an image or animation.\n    Supports `.png`, `.webp`, `.jpg`, `.jpeg`, `.bmp`, `.tiff`, `.gif` and `.heic, .heif` if pillow-heif library is installed.\n\n    Args:\n        path: File path.\n        device_info: Device information (injected automatically by DeviceSession).\n        resize_method: Resize method - 'crop' (default) or 'fit'. \n                  'crop' will fill the entire target area and crop excess.\n                  'fit' will fit the entire image with black padding.\n        save_slot: If &gt;= 1, will save to that slot.\n\n    Note:\n        If device_info is available, the image will be automatically resized\n        to match the target device dimensions if necessary.\n    \"\"\"\n\n    # Input normalization\n    if isinstance(resize_method, str):\n        resize_method = ResizeMethod(resize_method)\n    if isinstance(path, str):\n        path = Path(path)\n    save_slot = int(save_slot)\n\n    # Load image data\n    if path.exists() and path.is_file():\n        with open(path, \"rb\") as f:\n            file_bytes = f.read()\n        file_bytes, is_gif = _process_loaded_bytes(file_bytes, path.suffix.lower())\n    else:\n        raise ValueError(f\"File not found: {path}\")\n\n    # Resize image if device_info is available\n    if device_info is not None:\n        file_bytes = _resize_image(file_bytes, is_gif, device_info.width, device_info.height, resize_method)\n    else:\n        logger.warning(\"Device info not provided; skipping image resizing.\")\n\n    return _build_send_plan(file_bytes, is_gif, plan_name=\"send_image\", save_slot=save_slot)\n</code></pre>"},{"location":"commands/#send_image_hex","title":"<code>send_image_hex</code>","text":"<p>Send an image or animation from a hexadecimal string.</p> <p>Parameters:</p> Name Type Description Default <code>hex_string</code> <code>Union[str, bytes]</code> <p>Hexadecimal representation of image data.</p> required <code>file_extension</code> <code>str</code> <p>File extension to indicate image type (e.g. <code>.png</code>, <code>.gif</code>).</p> required <code>device_info</code> <code>Optional[DeviceInfo]</code> <p>Device information (injected automatically by DeviceSession).</p> <code>None</code> <code>resize_method</code> <code>Union[str, ResizeMethod]</code> <p>Resize method - 'crop' (default) or 'fit'.        'crop' will fill the entire target area and crop excess.       'fit' will fit the entire image with black padding.</p> <code>CROP</code> <code>save_slot</code> <code>int</code> <p>If &gt;= 1, will save to that slot.</p> <code>0</code> Source code in <code>src/pypixelcolor/commands/send_image.py</code> <pre><code>def send_image_hex(hex_string: Union[str, bytes], file_extension: str, resize_method: Union[str, ResizeMethod] = ResizeMethod.CROP, device_info: Optional[DeviceInfo] = None, save_slot: int = 0):\n    \"\"\"\n    Send an image or animation from a hexadecimal string.\n\n    Args:\n        hex_string: Hexadecimal representation of image data.\n        file_extension: File extension to indicate image type (e.g. `.png`, `.gif`).\n        device_info: Device information (injected automatically by DeviceSession).\n        resize_method: Resize method - 'crop' (default) or 'fit'. \n                  'crop' will fill the entire target area and crop excess.\n                  'fit' will fit the entire image with black padding.\n        save_slot: If &gt;= 1, will save to that slot.\n    \"\"\"\n    # Input normalization\n    if isinstance(resize_method, str):\n        resize_method = ResizeMethod(resize_method)\n\n    # Load image data from hex string\n    file_bytes, is_gif = _load_from_hex_string(hex_string, file_extension)\n\n    # Resize image if device_info is available\n    if device_info is not None:\n        file_bytes = _resize_image(file_bytes, is_gif, device_info.width, device_info.height, resize_method)\n    else:\n        logger.warning(\"Device info not provided; skipping image resizing.\")\n\n    return _build_send_plan(file_bytes, is_gif, plan_name=\"send_image_hex\", save_slot=save_slot)\n</code></pre>"},{"location":"commands/#send_text","title":"<code>send_text</code>","text":"<p>Send a text to the device with configurable parameters. If emojis are included in the text, they will be rendered using Twemoji.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The text to send.</p> required <code>rainbow_mode</code> <code>int</code> <p>Rainbow mode (0-9). Defaults to 0.</p> <code>0</code> <code>animation</code> <code>int</code> <p>Animation type (0-7, except 3 and 4). Defaults to 0.</p> <code>0</code> <code>save_slot</code> <code>int</code> <p>Save slot (1-10). Defaults to 1.</p> <code>0</code> <code>speed</code> <code>int</code> <p>Animation speed (0-100). Defaults to 80.</p> <code>80</code> <code>color</code> <code>str</code> <p>Text color in hex. Defaults to \"ffffff\".</p> <code>'ffffff'</code> <code>bg_color</code> <code>str</code> <p>Background color in hex (e.g., \"ff0000\" for red). Defaults to None (no background).</p> <code>None</code> <code>font</code> <code>str | FontConfig</code> <p>Built-in font name, file path, or FontConfig object. Defaults to \"CUSONG\". Built-in fonts are \"CUSONG\", \"SIMSUN\", \"VCR_OSD_MONO\".</p> <code>'CUSONG'</code> <code>char_height</code> <code>int</code> <p>Character height. Auto-detected from device_info if not specified.</p> <code>None</code> <code>device_info</code> <code>DeviceInfo</code> <p>Device information (injected automatically by DeviceSession).</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If an invalid animation is selected or parameters are out of range.</p> Source code in <code>src/pypixelcolor/commands/send_text/__init__.py</code> <pre><code>def send_text(text: str,\n              rainbow_mode: int = 0,\n              animation: int = 0,\n              save_slot: int = 0,\n              speed: int = 80,\n              color: str = \"ffffff\",\n              bg_color: Optional[str] = None,\n              font: Union[str, FontConfig] = \"CUSONG\",\n              char_height: Optional[int] = None,\n              device_info: Optional[DeviceInfo] = None\n              ):\n    \"\"\"\n    Send a text to the device with configurable parameters.\n    If emojis are included in the text, they will be rendered using Twemoji.\n\n    Args:\n        text (str): The text to send.\n        rainbow_mode (int, optional): Rainbow mode (0-9). Defaults to 0.\n        animation (int, optional): Animation type (0-7, except 3 and 4). Defaults to 0.\n        save_slot (int, optional): Save slot (1-10). Defaults to 1.\n        speed (int, optional): Animation speed (0-100). Defaults to 80.\n        color (str, optional): Text color in hex. Defaults to \"ffffff\".\n        bg_color (str, optional): Background color in hex (e.g., \"ff0000\" for red). Defaults to None (no background).\n        font (str | FontConfig, optional): Built-in font name, file path, or FontConfig object. Defaults to \"CUSONG\". Built-in fonts are \"CUSONG\", \"SIMSUN\", \"VCR_OSD_MONO\".\n        char_height (int, optional): Character height. Auto-detected from device_info if not specified.\n        device_info (DeviceInfo, optional): Device information (injected automatically by DeviceSession).\n\n    Raises:\n        ValueError: If an invalid animation is selected or parameters are out of range.\n    \"\"\"\n\n    # Resolve font configuration\n    font_config = resolve_font_config(font)\n\n    # Auto-detect char_height from device_info if available\n    if char_height is None:\n        if device_info is not None:\n            char_height = get_char_height_from_device(device_info)\n            logger.debug(f\"Auto-detected matrix height from device (height={device_info.height}): {char_height}\")\n        else:\n            raise ValueError(\"char_height must be specified if device_info is not provided\")\n\n    char_height = int(char_height)\n\n    # Get metrics for this character height\n    metrics = font_config.get_metrics(char_height)\n    font_size = metrics[\"font_size\"]\n    font_offset = metrics[\"offset\"]\n    pixel_threshold = metrics[\"pixel_threshold\"]\n    var_width = metrics[\"var_width\"]\n\n    # properties: 3 fixed bytes + animation + speed + rainbow + 3 bytes color + 1 byte bg flag + 3 bytes bg color\n    try:\n        color_bytes = bytes.fromhex(color)\n    except Exception:\n        raise ValueError(f\"Invalid color hex: {color}\")\n    if len(color_bytes) != 3:\n        raise ValueError(\"Color must be 3 bytes (6 hex chars), e.g. 'ffffff'\")\n\n    # Validate parameter ranges\n    checks = [\n        (int(rainbow_mode), 0, 9, \"Rainbow mode\"),\n        (int(animation), 0, 7, \"Animation\"),\n        (int(save_slot), 0, 255, \"Save slot\"),\n        (int(speed), 0, 100, \"Speed\"),\n        (len(text), 1, 500, \"Text length\"),\n        (char_height, 1, 128, \"Char height\"),\n    ]\n    for param, min_val, max_val, name in checks:\n        if not (min_val &lt;= param &lt;= max_val):\n            raise ValueError(f\"{name} must be between {min_val} and {max_val} (got {param})\")\n\n    # Disable unsupported animations (bootloop)\n    if device_info and (device_info.height != 32 or device_info.width != 32):\n        if (int(animation) == 3 or int(animation) == 4):\n            raise ValueError(\"This animation is not supported with this font on non-32x32 devices.\")\n\n    # Determine if RTL mode should be enabled (only for animation 2)\n    rtl = (int(animation) == 2)\n    if rtl:\n        logger.debug(\"Reversed chunk order for RTL display\")\n\n    #---------------- BUILD PAYLOAD ----------------#\n\n    #########################\n    #       PROPERTIES      #\n    #########################\n\n    properties = bytearray()\n    properties += bytes([\n        0x00,   # Reserved\n        0x01,   # Reserved\n        0x01    # Reserved\n    ])\n    properties += bytes([\n        int(animation) &amp; 0xFF,      # Animation\n        int(speed) &amp; 0xFF,          # Speed\n        int(rainbow_mode) &amp; 0xFF    # Rainbow mode\n    ])\n    properties += color_bytes\n\n    # Trailing 4 bytes - Background color: [enable_flag, R, G, B]\n    if bg_color is not None:\n        try:\n            bg_color_bytes = bytes.fromhex(bg_color)\n        except Exception:\n            raise ValueError(f\"Invalid background color hex: {bg_color}\")\n        if len(bg_color_bytes) != 3:\n            raise ValueError(\"Background color must be 3 bytes (6 hex chars), e.g. 'ff0000'\")\n        properties += bytes([0x01])  # Enable background\n        properties += bg_color_bytes\n        logger.info(f\"Background color enabled: #{bg_color}\")\n    else:\n        properties += bytes([\n            0x00,   # Background disabled\n            0x00,   # R (unused)\n            0x00,   # G (unused)\n            0x00    # B (unused)\n        ])\n\n    #########################\n    #       CHARACTERS      #\n    #########################\n\n    if var_width:\n        # Determine chunk width based on char_height\n        chunk_width = 8  if char_height &lt;= 20 else 16\n\n        # Encode text with chunks and emoji support, getting both bytes and item count\n        characters_bytes, num_chars = encode_text_chunked(\n            text,\n            char_height,\n            color,\n            font_config.path,\n            font_offset,\n            font_size,\n            pixel_threshold,\n            chunk_width,\n            reverse=rtl\n        )\n    else:\n        # Original character-by-character encoding\n        characters_bytes = encode_text(\n            text,\n            char_height,\n            color,\n            font_config.path,\n            font_offset,\n            font_size,\n            pixel_threshold,\n            reverse=rtl\n        )\n\n        # Number of characters is the length of the text\n        num_chars = len(text)\n\n    # Build data payload with character count\n    data_payload = bytes([num_chars]) + properties + characters_bytes\n\n    #########################\n    #        CHECKSUM       #\n    #########################\n\n    crc = binascii.crc32(data_payload) &amp; 0xFFFFFFFF\n    payload_size = len(data_payload)\n\n    #########################\n    #      MULTI-FRAME      #\n    #########################\n\n    windows = []\n    window_size = 12 * 1024\n    pos = 0\n    window_index = 0\n\n    while pos &lt; payload_size:\n        window_end = min(pos + window_size, payload_size)\n        chunk_payload = data_payload[pos:window_end]\n\n        # Option: 0x00 for first frame, 0x02 for subsequent frames\n        option = 0x00 if window_index == 0 else 0x02\n\n        # Construct header for this frame\n        # [00 01 Option] [Payload Size (4)] [CRC (4)] [00 SaveSlot]\n\n        frame_header = bytearray()\n        frame_header += bytes([\n            0x00,   # Reserved\n            0x01,   # Command\n            option  # Option\n        ])\n\n        # Payload Size (Total) - 4 bytes little endian\n        frame_header += payload_size.to_bytes(4, byteorder=\"little\")\n\n        # CRC - 4 bytes little endian\n        frame_header += crc.to_bytes(4, byteorder=\"little\")\n\n        # Tail - 2 bytes\n        frame_header += bytes([0x00])                   # Reserved\n        frame_header += bytes([int(save_slot) &amp; 0xFF])  # save_slot\n\n        # Combine header and chunk\n        frame_content = frame_header + chunk_payload\n\n        # Calculate frame length prefix\n        # Total size = len(frame_content) + 2 (for the prefix itself)\n        frame_len = len(frame_content) + 2\n        prefix = frame_len.to_bytes(2, byteorder=\"little\")\n\n        message = prefix + frame_content\n        windows.append(Window(data=message, requires_ack=True))\n\n        window_index += 1\n        pos = window_end\n\n    logger.info(f\"Split text into {len(windows)} frames\")\n    return SendPlan(\"send_text\", windows)\n</code></pre>"},{"location":"commands/#set_brightness","title":"<code>set_brightness</code>","text":"<p>Set the brightness of the device.</p> <p>Parameters:</p> Name Type Description Default <code>level</code> <code>int</code> <p>Brightness level (0-100).</p> required Source code in <code>src/pypixelcolor/commands/set_brightness.py</code> <pre><code>def set_brightness(level: int):\n    \"\"\"\n    Set the brightness of the device.\n\n    Args:\n        level (int): Brightness level (0-100).\n    \"\"\"\n    if (0 &gt; int(level)) or (int(level) &gt; 100):\n        raise ValueError(\"Brightness level must be between 0 and 100\")\n    payload = bytes([\n        5,          # Command length\n        0,          # Reserved\n        4,          # Command ID\n        0x80,       # Command type ID\n        int(level)  # Brightness value\n    ])\n    return single_window_plan(\"set_brightness\", payload)\n</code></pre>"},{"location":"commands/#set_clock_mode","title":"<code>set_clock_mode</code>","text":"<p>Set the clock mode of the device.</p> <p>Parameters:</p> Name Type Description Default <code>style</code> <code>int</code> <p>The clock style (0-8). Defaults to 1.</p> <code>1</code> <code>date</code> <code>str</code> <p>The date to display (DD/MM/YYYY). Defaults to today.</p> <code>''</code> <code>show_date</code> <code>bool</code> <p>Whether to show the date. Defaults to True.</p> <code>True</code> <code>format_24</code> <code>bool</code> <p>Whether to use 24-hour format. Defaults to True.</p> <code>True</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If any parameter is out of range or invalid.</p> Source code in <code>src/pypixelcolor/commands/set_clock_mode.py</code> <pre><code>def set_clock_mode(style: int = 1, date=\"\", show_date: bool = True, format_24: bool = True):\n    \"\"\"\n    Set the clock mode of the device.\n\n    Args:\n        style (int, optional): The clock style (0-8). Defaults to 1.\n        date (str, optional): The date to display (DD/MM/YYYY). Defaults to today.\n        show_date (bool, optional): Whether to show the date. Defaults to True.\n        format_24 (bool, optional): Whether to use 24-hour format. Defaults to True.\n\n    Raises:\n        ValueError: If any parameter is out of range or invalid.\n    \"\"\"\n    if isinstance(show_date, str):\n        show_date = show_date.lower() in (\"true\", \"1\", \"yes\", \"on\")\n    if isinstance(format_24, str):\n        format_24 = format_24.lower() in (\"true\", \"1\", \"yes\", \"on\")\n\n    # Process date\n    if not date:\n        now = datetime.now()\n        day, month, year = now.day, now.month, now.year % 100\n        day_of_week = now.weekday() + 1\n    else:\n        try:\n            day, month, year = map(int, date.split(\"/\"))\n            day_of_week = datetime(year, month, day).weekday() + 1\n        except (ValueError, IndexError) as e:\n            raise ValueError(f\"Invalid date format: {e}\")\n\n    # Validate ranges\n    if int(style) not in range(0, 9):\n        raise ValueError(\"Clock style must be between 0 and 8\")\n    if int(day_of_week) not in range(1, 8):\n        raise ValueError(\"Day of week must be between 1 and 7\")\n    if int(year) not in range(0, 100):\n        raise ValueError(\"Year must be between 0 and 99\")\n    if int(month) not in range(1, 13):\n        raise ValueError(\"Month must be between 1 and 12\")\n    if int(day) not in range(1, 32):\n        raise ValueError(\"Day must be between 1 and 31\")\n\n    # Build byte sequence using direct bytes constructions\n    header = bytes([\n        11, # Command length \n        0,  # Reserved\n        6,  # Command ID\n        1   # Command type ID\n    ])\n\n    params = bytes([\n        int(style) &amp; 0xFF,                # Clock style\n        1 if bool(format_24) else 0,      # 24-hour format\n        1 if bool(show_date) else 0,      # Show date\n    ])\n\n    date_bytes = bytes([\n        year &amp; 0xFF,                   # Year\n        month &amp; 0xFF,                  # Month\n        day &amp; 0xFF,                    # Day\n        day_of_week &amp; 0xFF,            # Day of week\n    ])\n\n    payload = header + params + date_bytes\n    return single_window_plan(\"set_clock_mode\", payload)\n</code></pre>"},{"location":"commands/#set_fun_mode","title":"<code>set_fun_mode</code>","text":"<p>Enable or disable fun mode.</p> <p>Parameters:</p> Name Type Description Default <code>enable</code> <code>bool</code> <p>Boolean or equivalent, enables (True) or disables (False) fun mode.</p> <code>False</code> Source code in <code>src/pypixelcolor/commands/set_fun_mode.py</code> <pre><code>def set_fun_mode(enable : bool = False):\n    \"\"\"\n    Enable or disable fun mode.\n\n    Args:\n        enable: Boolean or equivalent, enables (True) or disables (False) fun mode.\n    \"\"\"\n\n    # Convert bool\n    if isinstance(enable, str):\n        enable = enable.lower() in (\"true\", \"1\", \"yes\", \"on\")\n\n    # Build payload using bytes\n    payload = bytes([\n        5,                        # Command length\n        0,                        # Reserved\n        4,                        # Command ID\n        1,                        # Command type ID\n        1 if bool(enable) else 0  # Fun mode value\n    ])\n\n    return single_window_plan(\"set_fun_mode\", payload)\n</code></pre>"},{"location":"commands/#set_pixel","title":"<code>set_pixel</code>","text":"<p>Defines the color of a specific pixel.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>int</code> <p>X coordinate of the pixel (0-...).</p> required <code>y</code> <code>int</code> <p>Y coordinate of the pixel (0-...).</p> required <code>color</code> <code>str</code> <p>Color in hexadecimal format (e.g., 'FF0000' for red).</p> required Source code in <code>src/pypixelcolor/commands/set_fun_mode.py</code> <pre><code>def set_pixel(x: int, y: int, color: str, device_info: Optional[DeviceInfo] = None):\n    \"\"\"\n    Defines the color of a specific pixel.\n\n    Args:\n        x: X coordinate of the pixel (0-...).\n        y: Y coordinate of the pixel (0-...).\n        color: Color in hexadecimal format (e.g., 'FF0000' for red).\n    \"\"\"\n\n    # Validate coordinates range if device info is provided\n    if device_info and not (0 &lt;= int(x) &lt;= device_info.width - 1 and 0 &lt;= int(y) &lt;= device_info.height - 1):\n            raise ValueError(f\"Invalid coordinates range. Range are x[0:{device_info.width-1}] y[0:{device_info.height-1}]\")\n\n    # Validate color format\n    if (not (isinstance(color, str)) \n        and len(color) == 6 \n        and all(c in '0123456789abcdefABCDEF' for c in color)):\n            raise ValueError(\"Color must be a 6-character hexadecimal string.\")\n\n    # Build payload using bytes\n    payload = bytes([\n        10,                       # Command length\n        0,                        # Reserved\n        5,                        # Command ID\n        1,                        # Command type ID\n        0,                        # Reserved\n        int(color[0:2], 16),      # Red\n        int(color[2:4], 16),      # Green\n        int(color[4:6], 16),      # Blue\n        int(x),                   # X coordinate\n        int(y)                    # Y coordinate\n    ])\n\n    return single_window_plan(\"set_pixel\", payload, requires_ack=False)\n</code></pre>"},{"location":"commands/#set_orientation","title":"<code>set_orientation</code>","text":"<p>Set the orientation of the device.</p> <p>Parameters:</p> Name Type Description Default <code>orientation</code> <code>int</code> <p>The orientation value to set (0-3).</p> <code>0</code> Source code in <code>src/pypixelcolor/commands/set_orientation.py</code> <pre><code>def set_orientation(orientation: int = 0):\n    \"\"\"\n    Set the orientation of the device.\n\n    Args:\n        orientation (int): The orientation value to set (0-3).\n    \"\"\"\n\n    if (int(orientation) &lt; 0 or int(orientation) &gt; 3):\n        raise ValueError(\"Orientation must be between 0 and 3\")\n\n    payload = bytes([\n        5,                  # Command length\n        0,                  # Reserved  \n        6,                  # Command ID\n        0x80,               # Command type ID\n        int(orientation)    # Orientation value\n    ])\n    return single_window_plan(\"set_orientation\", payload)\n</code></pre>"},{"location":"commands/#set_power","title":"<code>set_power</code>","text":"<p>Set the power state of the device.</p> <p>Parameters:</p> Name Type Description Default <code>on</code> <code>bool</code> <p>True to turn on, False to turn off.</p> <code>True</code> Source code in <code>src/pypixelcolor/commands/set_power.py</code> <pre><code>def set_power(on: bool = True):\n    \"\"\"\n    Set the power state of the device.\n\n    Args:\n        on: True to turn on, False to turn off.\n    \"\"\"\n    if isinstance(on, str):\n        on = on.lower() in (\"true\", \"1\", \"yes\", \"on\")\n\n    # Build command\n    cmd = bytes([\n        5,              # Command length\n        0,              # Reserved\n        7,              # Command ID\n        1,              # Command type ID\n        1 if on else 0  # Power state\n    ])\n    return single_window_plan(\"set_power\", cmd)\n</code></pre>"},{"location":"commands/#set_rhythm_mode","title":"<code>set_rhythm_mode</code>","text":"<p>Set the rhythm mode of the device.</p> <p>Parameters:</p> Name Type Description Default <code>style</code> <code>int</code> <p>The style of the rhythm mode (0-4).</p> <code>0</code> <code>l1</code> <code>int</code> <p>Level 1 (0-15).</p> <code>0</code> <code>l2</code> <code>int</code> <p>Level 2 (0-15).</p> <code>0</code> <code>l3</code> <code>int</code> <p>Level 3 (0-15).</p> <code>0</code> <code>l4</code> <code>int</code> <p>Level 4 (0-15).</p> <code>0</code> <code>l5</code> <code>int</code> <p>Level 5 (0-15).</p> <code>0</code> <code>l6</code> <code>int</code> <p>Level 6 (0-15).</p> <code>0</code> <code>l7</code> <code>int</code> <p>Level 7 (0-15).</p> <code>0</code> <code>l8</code> <code>int</code> <p>Level 8 (0-15).</p> <code>0</code> <code>l9</code> <code>int</code> <p>Level 9 (0-15).</p> <code>0</code> <code>l10</code> <code>int</code> <p>Level 10 (0-15).</p> <code>0</code> <code>l11</code> <code>int</code> <p>Level 11 (0-15).</p> <code>0</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>style</code> is not in 0..4 or any level is not in 0..15.</p> Source code in <code>src/pypixelcolor/commands/set_rhythm_mode.py</code> <pre><code>def set_rhythm_mode(style=0, l1 : int = 0, l2 : int = 0, l3 : int = 0, l4 : int = 0, l5 : int = 0, l6 : int = 0, l7 : int = 0, l8 : int = 0, l9 : int = 0, l10 : int = 0, l11 : int = 0):\n    \"\"\"Set the rhythm mode of the device.\n\n    Args:\n        style (int): The style of the rhythm mode (0-4).\n        l1 (int): Level 1 (0-15).\n        l2 (int): Level 2 (0-15).\n        l3 (int): Level 3 (0-15).\n        l4 (int): Level 4 (0-15).\n        l5 (int): Level 5 (0-15).\n        l6 (int): Level 6 (0-15).\n        l7 (int): Level 7 (0-15).\n        l8 (int): Level 8 (0-15).\n        l9 (int): Level 9 (0-15).\n        l10 (int): Level 10 (0-15).\n        l11 (int): Level 11 (0-15).\n\n    Raises:\n        ValueError: If ``style`` is not in 0..4 or any level is not in 0..15.\n    \"\"\"\n\n    # Validation\n    if not (0 &lt;= int(style) &lt;= 4):\n        raise ValueError(f\"rhythm mode style must be between 0 and 4, got {style}\")\n\n    levels = [int(v) for v in [l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11]]\n    for idx, lv in enumerate(levels, start=1):\n        if not (0 &lt;= lv &lt;= 15):\n            raise ValueError(f\"level {idx} must be between 0 and 15, got {lv}\")\n\n    # Build payload\n    payload = bytes([\n        16,     # Command length\n        0,      # Reserved\n        1,      # Command ID\n        2,      # Command type ID\n        int(style),\n    ])\n    payload += bytes(levels)\n\n    return single_window_plan(\"set_rhythm_mode\", payload, requires_ack=True)\n</code></pre>"},{"location":"commands/#set_time","title":"<code>set_time</code>","text":"<p>Set the device time. Note : Command is the same as get_device_info.</p> <p>Parameters:</p> Name Type Description Default <code>hour</code> <code>Optional[int]</code> <p>Hour to set (0-23). If None, uses current hour.</p> <code>None</code> <code>minute</code> <code>Optional[int]</code> <p>Minute to set (0-59). If None, uses current minute.</p> <code>None</code> <code>second</code> <code>Optional[int]</code> <p>Second to set (0-59). If None, uses current second.</p> <code>None</code> Source code in <code>src/pypixelcolor/commands/set_time.py</code> <pre><code>def set_time(hour: Optional[int] = None, minute: Optional[int] = None, second: Optional[int] = None):\n    \"\"\"\n    Set the device time.\n    Note : Command is the same as get_device_info.\n\n    Args:\n        hour: Hour to set (0-23). If None, uses current hour.\n        minute: Minute to set (0-59). If None, uses current minute.\n        second: Second to set (0-59). If None, uses current second.\n    \"\"\"\n    # Get current time if any component is None\n    if hour is None or minute is None or second is None:\n        now = datetime.now()\n        hour = now.hour if hour is None else hour\n        minute = now.minute if minute is None else minute\n        second = now.second if second is None else second\n\n    # Validate\n    if not (0 &lt;= int(hour) &lt;= 23):\n        raise ValueError(\"Hour must be between 0 and 23\")\n    if not (0 &lt;= int(minute) &lt;= 59):\n        raise ValueError(\"Minute must be between 0 and 59\")\n    if not (0 &lt;= int(second) &lt;= 59):\n        raise ValueError(\"Second must be between 0 and 59\")\n\n    # Build command\n    cmd = bytes([\n        8,              # Command length\n        0,              # Reserved\n        1,              # Command ID\n        0x80,           # Command type ID\n        int(hour),      # Hour\n        int(minute),    # Minute\n        int(second),    # Second\n        0               # Reserved\n    ])\n    return single_window_plan(\"set_time\", cmd)\n</code></pre>"},{"location":"commands/#show_slot","title":"<code>show_slot</code>","text":"<p>Shows the specified slot on the device.</p> <p>Parameters:</p> Name Type Description Default <code>number</code> <code>int</code> <p>The slot number to display.</p> required Source code in <code>src/pypixelcolor/commands/show_slot.py</code> <pre><code>def show_slot(number: int):\n    \"\"\"\n    Shows the specified slot on the device.\n\n    Args:\n        number: The slot number to display.\n    \"\"\"\n    cmd = bytes([\n        0x07,\n        0x00,\n        0x08,\n        0x80,\n        0x01,\n        0x00,\n        int(number) &amp; 0xFF,\n    ])\n    return single_window_plan(\"show_slot\", cmd)\n</code></pre>"},{"location":"troubleshooting/","title":"Troubleshooting","text":"<p>Here are some common issues and solutions when using <code>pypixelcolor</code>.</p>"},{"location":"troubleshooting/#bluetooth-connection-issues","title":"Bluetooth Connection Issues","text":""},{"location":"troubleshooting/#device-not-found","title":"Device not found","text":"<ul> <li>Ensure the device is powered on.</li> <li>Ensure the device is not connected to another phone or computer. The device can only handle one BLE connection at a time.</li> <li>Try moving closer to the device.</li> </ul>"},{"location":"troubleshooting/#connection-timeout","title":"Connection Timeout","text":"<p>If you experience timeouts when connecting:</p> <ul> <li>Restart the Bluetooth service on your computer.</li> <li>Power cycle the LED device.</li> </ul>"},{"location":"troubleshooting/#linux-specifics","title":"Linux Specifics","text":"<p>On Linux, you might need to ensure your user has the correct permissions to access the Bluetooth adapter.</p> <ol> <li>Ensure <code>bluez</code> is installed.</li> <li>Add your user to the <code>bluetooth</code> group (if it exists) or check your distribution's documentation for BLE permissions.</li> </ol> <pre><code>sudo usermod -aG bluetooth $USER\n</code></pre> <p>You may need to log out and log back in for changes to take effect.</p>"},{"location":"getting_started/cli/","title":"Getting started with CLI","text":"<p>Find your device's MAC address by scanning for nearby Bluetooth devices:</p> <pre><code>pypixelcolor --scan\n</code></pre> <p></p> <p>If your device is found, take note of its MAC address (e.g., <code>30:E1:AF:BD:5F:D0</code>).</p> <pre><code>% pypixelcolor --scan\n\u2139\ufe0f [2025-11-18 21:07:35] [pypixelcolor.cli] Scanning for Bluetooth devices...\n\u2139\ufe0f [2025-11-18 21:07:40] [pypixelcolor.cli] Found 1 device(s):\n\u2139\ufe0f [2025-11-18 21:07:40] [pypixelcolor.cli]   - LED_BLE_E1BD5C80 (30:E1:AF:BD:5F:D0)\n</code></pre> <p>If your device is not found, ensure it is powered, in range and not connected to another device.</p> <p>To send a text message to your device, use the following command, replacing the MAC address with your device's MAC address:</p> <pre><code>pypixelcolor -a &lt;MAC_ADDRESS&gt; -c send_text \"Hello pypixelcolor\"\n</code></pre> <p>You can also add optional parameters to customize the display:</p> <pre><code>pypixelcolor -a &lt;MAC_ADDRESS&gt; -c send_text \"Hello pypixelcolor\" animation=1 speed=100\n</code></pre> <p>You can execute multiple commands in a single call. For example, to clear the display, set the brightness to 0, and switch to clock mode, you can run:</p> <pre><code>pypixelcolor -a &lt;MAC_ADDRESS&gt; -c clear -c set_brightness 0 -c set_clock_mode\n</code></pre> <p>For more information on available commands, refer to the Commands page.</p>"},{"location":"getting_started/library/","title":"Using pypixelcolor as a Python library","text":""},{"location":"getting_started/library/#basic-usage","title":"Basic Usage","text":"<p>You can also use <code>pypixelcolor</code> as a Python library in your own scripts.</p> <pre><code>import pypixelcolor\n\n# Create a PixelColor device instance\ndevice = pypixelcolor.Client(\"30:E1:AF:BD:5F:D0\")\n\n# Connect to the device\ndevice.connect()\n\n# Send a text message to the device\ndevice.send_text(\"Hello from Python!\", animation=1, speed=100)\n\n# Disconnect from the device\ndevice.disconnect()\n</code></pre>"},{"location":"getting_started/library/#multiple-devices","title":"Multiple Devices","text":"<p>You can connect to multiple devices by creating multiple <code>Client</code> instances:</p> <pre><code>import pypixelcolor\n\ndevices = [\n    pypixelcolor.Client(\"30:E1:AF:BD:5F:D0\"), \n    pypixelcolor.Client(\"30:E1:AF:BD:20:A9\")\n]\n\nfor device in devices:\n    device.connect()\n\nfor device in devices:\n    device.send_text(\"Hello from Python!\", animation=1, speed=100)\n\nfor device in devices:\n    device.disconnect()\n</code></pre> <p>You can send commands to multiple iPixel Color devices concurrently using asynchronous programming with the <code>asyncio</code> library. Below is an example of how to achieve this:</p> <pre><code>import asyncio\nimport pypixelcolor\n\nasync def main():\n    addresses = [\n        \"30:E1:AF:BD:5F:D0\",\n        \"30:E1:AF:BD:20:A9\",\n    ]\n\n    # Create clients and connect sequentially (safe for common backends)\n    devices = []\n    for addr in addresses:\n        client = pypixelcolor.AsyncClient(addr)\n        await client.connect()\n        devices.append(client)\n\n    if not devices:\n        return\n\n    # Launch sends concurrently across all connected devices\n    tasks = [asyncio.create_task(d.send_image(\"./python.png\")) for d in devices]\n    await asyncio.gather(*tasks)\n\n    # Disconnect all\n    for d in devices:\n        await d.disconnect()\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre> <p>\u26a0\ufe0f Heavy data operations (like image sending) are not stable when performed concurrently on multiple devices due to potential Bluetooth backend limitations.</p>"},{"location":"getting_started/websocket/","title":"Running WebSocket Server","text":"<p>A WebSocket server is included to allow real-time control of your device. To start the server, use the following command:</p> <pre><code>python -m pypixelcolor.websocket -a &lt;MAC_ADDRESS&gt;\n</code></pre> <p>By default, the server listens on <code>localhost:4444</code>. You can specify a different host and port using the <code>--host</code> and <code>--port</code> options:</p> <pre><code>python -m pypixelcolor.websocket -a &lt;MAC_ADDRESS&gt; --host 0.0.0.0 --port 4444\n</code></pre> <p>Using a WebSocket client (for example, WebSocket King), and connect to the server at the specified host and port (by default <code>ws://localhost:4444</code>). Once connected, you can send commands in JSON format. For example, to send a text message with animation and speed settings, you can use the following JSON payload:</p> <pre><code>{\n  \"command\": \"send_text\",\n  \"params\": [\n    \"text=Hello from WebSocket\",\n    \"animation=1\",\n    \"speed=100\"\n  ]\n}\n</code></pre> <p>For more information on available commands, refer to the Commands page.</p>"},{"location":"guides/android_ble_logs/","title":"Getting BLE logs from an Android device","text":""},{"location":"guides/android_ble_logs/#requirements","title":"Requirements","text":"<ul> <li>An Android device with Bluetooth capabilities</li> <li>adb (Android Debug Bridge) installed on your computer</li> <li>USB cable to connect the Android device to your computer (or Wifi for wireless setup)</li> <li>Wireshark if you want to analyze the logs</li> </ul>"},{"location":"guides/android_ble_logs/#step-by-step-guide","title":"Step-by-step guide","text":"<p>Before you start capturing BLE logs, you need to prepare your Android device.</p>"},{"location":"guides/android_ble_logs/#enable-usb-debugging-on-your-android-device","title":"Enable USB debugging on your Android device","text":"<ul> <li>Go to Settings &gt; About phone.</li> <li>Tap on Build number 7 times to enable Developer options.</li> <li>Go back to Settings &gt; Developer options and enable USB debugging.</li> </ul> <p>Steps may vary slightly depending on your Android version and device manufacturer.</p>"},{"location":"guides/android_ble_logs/#enable-bluetooth-hci-snoop-log-on-your-android-device","title":"Enable Bluetooth HCI snoop log on your Android device","text":"<p>Go to Settings &gt; Developer options. Scroll down and set Bluetooth HCI snoop log to Enabled. Restart the bluetooth service by toggling Bluetooth off and then on again.</p> <p>You can now do actions on your Android device that will generate BLE logs.</p>"},{"location":"guides/android_ble_logs/#capture-the-ble-logs","title":"Capture the BLE logs","text":"<p>When you are done, follow these steps to retrieve the logs:</p> <ol> <li>Connect your Android device to your computer using a USB cable or ensure you have a wireless ADB setup.</li> <li>Open a terminal or command prompt on your computer.</li> <li>Check if your device is connected by running:</li> </ol> <pre><code>adb devices\n</code></pre> <p>You should see your device listed.</p> <p>If you see \"unauthorized\", make sure to accept the USB debugging prompt on your Android device. 4. Generate a bugreport from your device by running:</p> <pre><code>adb bugreport \n</code></pre> <p>This command will create a zip file containing various logs, including the Bluetooth HCI snoop log.    The zip file will be saved in the current directory with a name like <code>bugreport-&lt;device_name&gt;-&lt;timestamp&gt;.zip</code>. 5. Extract the log from the bug report by unzipping <code>FS/data/misc/bluetooth/logs/btsnoop_hci_&lt;date&gt;_&lt;time&gt;.log</code>.     If you only have a file named <code>btsnooz_hci.log</code>, data sent to BLE devices has been filtered from logging, make sure you set Bluetooth HCI snoop log to Enabled and restart your device.</p> <ol> <li>Analyze the log file:</li> <li>You can open the <code>btsnoop_hci.log</code> file in Wireshark for analysis.</li> <li>In Wireshark, go to File &gt; Open and select the <code>btsnoop_hci.log</code> file.</li> <li>Protip: use filter <code>(btatt.opcode.method == 0x12)</code> to only view write requests sent to BLE devices.</li> </ol>"},{"location":"guides/custom_fonts/","title":"Custom Fonts","text":"<p>The library comes with built-in support for several fonts (CUSONG, SIMSUN, VCR_OSD_MONO). However, you can also use your own TTF files.</p>"},{"location":"guides/custom_fonts/#usage","title":"Usage","text":"<p>To use a custom font with the pypixelcolor library, you can specify the path to your TTF font file when sending text. Below is an example of how to do this:</p> <pre><code>import pypixelcolor\n\nif __name__ == \"__main__\":\n    client = pypixelcolor.Client(\"AF:1D:E1:BD:5C:80\")\n    client.connect()\n    client.send_text(\"Hello\", font=\"./Minecraft.ttf\")\n    client.disconnect()\n</code></pre> <p>A file must be created named with the same name as the TTF file but with a <code>.json</code> extension (e.g., <code>Minecraft.json</code>) in the same directory as the TTF file, containing the font metadata. Here is an example of what the JSON file should look like:</p> <pre><code>{\n  \"name\": \"Minecraft\",\n  \"metrics\": {\n    \"16\": {\n      \"font_size\": 16,\n      \"offset\": [0, 0],\n      \"pixel_threshold\": 70\n    },\n    \"20\": {\n      \"font_size\": 20,\n      \"offset\": [0, 0],\n      \"pixel_threshold\": 70\n    },\n    \"24\": {\n      \"font_size\": 24,\n      \"offset\": [0, -1],\n      \"pixel_threshold\": 80\n    },\n    \"32\": {\n      \"font_size\": 25,\n      \"offset\": [0, 2],\n      \"pixel_threshold\": 85\n    }\n  }\n}\n</code></pre>"},{"location":"guides/custom_fonts/#json-file-structure","title":"JSON File Structure","text":"<ul> <li><code>name</code>: The name of the font.</li> <li><code>metrics</code>: A dictionary where each key is a character height size (in pixels, 16, 20, 24 or 32) and the value is another dictionary containing:</li> <li><code>font_size</code>: The size of the font to be used.</li> <li><code>offset</code>: A list of two integers representing the x and y offset for rendering the font.</li> <li><code>pixel_threshold</code>: An integer value that determines the pixel intensity threshold for rendering the font.</li> </ul>"},{"location":"guides/custom_fonts/#notes","title":"Notes","text":"<ul> <li>Ensure that the TTF and JSON files are in the same directory.</li> <li>The font sizes specified in the JSON file should match the sizes you intend to use when sending text.</li> <li>Adjust the <code>offset</code> and <code>pixel_threshold</code> values as needed to achieve the desired appearance on your pixel device.</li> </ul>"}]}